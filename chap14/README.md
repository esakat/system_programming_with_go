# 14章のメモ

## 並列・並行の一般的な実現方法

* マルチプロセス
* イベント駆動
* マルチスレッド
* ストリーミング
* プロセッシング

## マルチプロセス

複数のCPUコアが並行して処理したり、1つのコアでも時間で分けて並列処理したり  
プロセス同士はメモリ空間がしっかり分割 -> 安全性高い
同じロジックを同時にサポートする場合は、フォークするとできる(起動コストは高い)

## イベント駆動

並列化ではなく、並行処理のために作られる  
ファイルI/OとかI/O待ちが多いプログラムとか  

イベント駆動とはOSが依頼をしたデータ受信の仕事が終わるたびにコールバックを返す仕組み
(常に1つのスレッドが受信したデータを処理するため、複数のコア間でデータ競合が発生しない)

また逐次処理になるため、タイミングによって結果が変わるということもあまりない  
またスレッドは違うけど、プロセスは同じになるため、CPUのコア間で情報共有しやすい

欠点としては、CPUを使いこなしにくい
イベント駆動で返ってきた結果を使ってさらに並行処理など
コードが複雑になりやすい

## マルチスレッド

マルチスレッドは同じメモリ空間内で多くのCPUが同時に実行するための仕組み

> Linuxではプロセスもスレッドもカーネル上では同じ構造体で表現されている
> 親プロセスとメモリ空間を共有していなければプロセス、共有していたらスレッドという整理

goroutineも軽量スレッド

マルチスレッドの利点はCPUパフォーマンス  
複数のコアの性能をうまく引き出せる  
またメモリ空間が共有されているので、データの共有が高速に行える

欠点としては、プロセスほどではないにしても、スレッドの生成コストはやはり少し高い  
スレッドプールを作っておいて、すぐに使えるようにしたりしている。  
またrubyやpythonのようなスクリプト言語だとパフォーマンスが出ない

## ストリーミング・プロセッシング

GPUとかに使われているらしい  

## 並行・並列の導入

アムダールの法則があり  
並列可能な処理の割合によって、並行・並列の嬉しみが増す

50%しか並行化できないのであれば、いくらコアを積んでも
最大で２倍のパフォーマンスにしかならない

### パターン

* 同期処理を非同期に
* 非同期処理を同期に
* Pub-Consu タスク生成と処理わけ
* 開始順で処理
* タスク処理が詰まったら待機
* 並列forループ
* あらかじめ決まった数のgoroutineで処理
* 依存関係のあるタスクを表現
* イベントの流れを定義
* 自立した複数のシステムで協調動作

## 同期処理を非同期に

重い処理をタスクに分ける(goroutineで非同期化)

```go
inputs := make(chan []byte)

go func() {
  a, _ := ioutil.ReadFile("a.txt")
  inputs<-a
}()

go func() {
  b, _ := ioutil.ReadFile("b.txt")
  inputs<-b
}()
```

## 非同期処理を同期に

非同期化したらどこかで、同期に戻す
さもないとGoの場合はmainが終わるとタスクが残ってても終了してしまう

Goの場合はチャネルを使うと簡単に非同期を同期に戻せる
普通に使うとブロックされるので、selectを使ったりが必要


## Pub-Consu タスク生成と処理わけ

タスク生成側(Producer), タスク消費者(Consumber)
GoだとチャネルでProducerとConsumerを使えば実現できる

プロセスをまたいでやる場合はMQを使うのが一般的

## 開始順で処理

チャネルでFIFOを実現できる
チャネルのチャネルにすると早く開始したものから順番に処理できる

```go

// チャネルに結果が投入された順に処理される
func writeToConn(responses chan *http.Response, conn net.Conn) {
  defer conn.Close()
  // 順番に取り出す
  for response := range responses {
    response.Write(conn)
  }
}

// チャネルにチャネルを入れた順で処理される
func writeToConn(sessionResponses chan chan *http.Response, conn net.Conn) {
  defer conn.Close()
  // 順番に取り出し
  for sessionResponse := range sessionResponses {
    // 選択された仕事が終わるまでまつ
    response := <-sessionResponse
    response.Write(conn)
  }
}
```

## back pressure

メールボックスが溢れそうな際の制御などに使われる
タスクが詰まりそうになったら緩和する制御

Goの場合はgoroutineの入力にバッファつきchanを使うと実現できる

```go
tasks := make(chan string, 10)
```

## 並列forループ

forループ内で、goroutineを使えば全て並列化できる