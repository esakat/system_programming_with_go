# 15章

## OSがメモリを確保するまで

プロセスが起動するとOSからメモリをもらう  

## ヒープとスタック

プログラムで処理のたびにメモリ確保はきつい
(メモリ確保はコスト大の処理)

プロセス起動時に確保したメモリを動的に利用していく

ヒープとスタック

## コードでメモリを使う

```go
var a int = 10

// 構造体のインスタンスを作成
// 変数にはポインタを保存
var b *Struct = new(Struct)

// 構造体に初期値を与えてインスタンスを作成
// 変数にはインスタンスを保存
var c *Struct = Struct{"param"}

// 構造体に初期値を与えてインスタンスを作成
// 変数にはポインタを保存
var d *Struct = &Struct{"param"}
```

C/C++では明示的にヒープorスタックを選択できるが  
Goではコンパイラが自動的に判断する  
newで作っても、その関数内でのみ利用であればスタック  
ローカル変数で宣言されても、そのポインタが別関数に渡されたりすると、ヒープに置かれる

## Go言語の配列

Go言語の配列は一般的な配列とは違う(固定長配列)  
可変長配列の場合はスライスを使う

固定長配列は要素数まで含めて型  

## Go言語のスライス

スライスは厳密には可変長配列ではない  
スライスの内部では固定長配列を生成したり、写したりしている

```go
// スライスの作成
// 既存の配列を元に
a := [4]int{1,2,3,4}
b := a[:] // len(b) == 4
c := a[1:3] // len(c) == 2
```

### appendのメモリ確保

append()はスライスと、追加したい引数を渡して、追加する  
cap()とlen()に差がある場合は、長さを伸ばして追加する  
cap()とlen()が同値の場合は、cap()の2倍のメモリを確保して
今までの要素をコピーして、新しい要素を新しいメモリ領域に追加

この通り、スライスの中身がどでかい場合は、appendはとてもコストが高くなる可能性がある
大量のコピーが必要になる場合は、事前にmake()コマンドで大きなメモリを確保しておくなどの工夫がいる

## がベージコレクタ

Goはシステムプログラミングできるかつ、ガベージコレクタが実装されている  
がベージコレクタのやり方はいくつかあるが、Goでは、マークアンドスイープという方法を採用

何度かメモリ領域をスキャンして、不必要なデータであれば、マークをつける
もう一回スキャンして、マークが付いていればメモリ解放する

これの課題はスキャン時にプログラムを少し止めないといけない(ストップザ・ワールド)
Goではこれをなるべく少なくしようと頑張っている

