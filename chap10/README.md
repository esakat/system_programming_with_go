# 10章のメモ(ファイルシステムの最深部を扱う)

`os`パッケージだけで扱えない奴を試してみる

## ファイルの変更監視(syscall.lnotify)

ファイルの変更を監視して、ビルドなどをするようにする  
方法は以下2つがある

* 監視したいファイルをOS側に通知しておいて、変更があったら教えてもらう(パッシブ方式)
* タイマーなどで定期的にフォルダを走査して、変更を探す(アクティブ方式)

実装としては後者が簡単だが、監視対象が増えるとCPU負荷や、IO負荷が上がる。  
前者の方式は環境ごとのコード差が大きくなる

## ファイルのロック(syscall.Flock)

ファイルのロックは複数のプロセス間で同じリソースを同時に変更しないように今使用していると他のプロセスに伝えること  
シンプルな方法はリソースが使用中であることをファイル(ロックファイル)によって示す  
ロックファイルは確実性の面で劣る。より確実なのはシステムコールを使用すること(Goだと`syscall.Flock`)  
ただこちらは強制力のないロック(勧告ロック)になってしまう

またこれはWindowsでは使えない。Windowsで使える`LockFileEx()`では強制ロックになる

ファイルのような共有リソースのロックには、共有ロックと排他ロックという区別があります。
共有ロックは複数プロセスから1つのリソースに同時にかけれる。  
排他ロックでは他のプロセスからの共有ロックがブロックされる  

Flockではすでロックされているファイルに対してロックをかけようとすると、最初のロックが外れるまで待たされる
ので、定期的になんどもアクセスしてロックが取得できるかトライすることが出来ない。
これを可能にするのが`ノンブロッキングモード`

## ファイルのメモリへのマッピング

`os.File`を使うと読み込む位置を指定して、そこに移動しないといけない  
`syscall.Mmap()`を使うと、ファイルをメモリ上に展開して、メモリ上で操作して、それをファイルに反映できる  

mmapの実行速度は、`File.Read()`に比べて速そうに見えるが、ケースバイケース  
前からの逐次処理であればそんなに変わらないが

DBからのデータをマッピングや、データの一部だけ、もしくはデータに操作権限の指定をする場合はmmapが良い

## 同期・非同期/ブロッキング・ノンブロッキング

ファイルI/OやネットワークI/OはCPU内部の処理に比べるとかなり遅い  
こういった重い処理に引きづられないように、同期/非同期、ブロッキング/ノンブロッキング処理がある

同期処理: OSにI/Oタスクを投げて、入出力の準備ができたらアプリが返す
非同期処理: OSにI/Oタスクを投げて、入出力の準備ができたら通知をもらう

ブロッキング処理: お願いしたI/Oタスクの結果ができるまでまつ(自分は停止しておく)
ノンブロッキング処理: お願いしたI/Oタスクの結果の準備ができるのをまたない。(自分も停止しない)