# 10章のメモ(ファイルシステムの最深部を扱う)

`os`パッケージだけで扱えない奴を試してみる

## ファイルの変更監視(syscall.lnotify)

ファイルの変更を監視して、ビルドなどをするようにする  
方法は以下2つがある

* 監視したいファイルをOS側に通知しておいて、変更があったら教えてもらう(パッシブ方式)
* タイマーなどで定期的にフォルダを走査して、変更を探す(アクティブ方式)

実装としては後者が簡単だが、監視対象が増えるとCPU負荷や、IO負荷が上がる。  
前者の方式は環境ごとのコード差が大きくなる

## ファイルのロック(syscall.Flock)

ファイルのロックは複数のプロセス間で同じリソースを同時に変更しないように今使用していると他のプロセスに伝えること  
シンプルな方法はリソースが使用中であることをファイル(ロックファイル)によって示す  
ロックファイルは確実性の面で劣る。より確実なのはシステムコールを使用すること(Goだと`syscall.Flock`)  
ただこちらは強制力のないロック(勧告ロック)になってしまう

またこれはWindowsでは使えない。Windowsで使える`LockFileEx()`では強制ロックになる

ファイルのような共有リソースのロックには、共有ロックと排他ロックという区別があります。
共有ロックは複数プロセスから1つのリソースに同時にかけれる。  
排他ロックでは他のプロセスからの共有ロックがブロックされる  

Flockではすでロックされているファイルに対してロックをかけようとすると、最初のロックが外れるまで待たされる
ので、定期的になんどもアクセスしてロックが取得できるかトライすることが出来ない。
これを可能にするのが`ノンブロッキングモード`

## ファイルのメモリへのマッピング

`os.File`を使うと読み込む位置を指定して、そこに移動しないといけない  
`syscall.Mmap()`を使うと、ファイルをメモリ上に展開して、メモリ上で操作して、それをファイルに反映できる  

mmapの実行速度は、`File.Read()`に比べて速そうに見えるが、ケースバイケース  
前からの逐次処理であればそんなに変わらないが

DBからのデータをマッピングや、データの一部だけ、もしくはデータに操作権限の指定をする場合はmmapが良い

## 同期・非同期/ブロッキング・ノンブロッキング

ファイルI/OやネットワークI/OはCPU内部の処理に比べるとかなり遅い  
こういった重い処理に引きづられないように、同期/非同期、ブロッキング/ノンブロッキング処理がある

同期処理: OSにI/Oタスクを投げて、入出力の準備ができたらアプリが返す
非同期処理: OSにI/Oタスクを投げて、入出力の準備ができたら通知をもらう

ブロッキング処理: お願いしたI/Oタスクの結果ができるまでまつ(自分は停止しておく)
ノンブロッキング処理: お願いしたI/Oタスクの結果の準備ができるのをまたない。(自分も停止しない)

### 同期・ブロッキング処理

読み込み書き込みが完了するまで、何もせず待ち続ける
重い処理があると、そこで全てが止まってしまう。  
パフォーマンスはあまり良くないが、コードはシンプルになりやすい

### 同期・ノンブロッキング処理

呼び出しをすると、準備が完了できたかをなんども送る(ポーリング)

### 非同期・ブロッキング処理

I/O多重化(I/Oマルチプレクサー)とも呼ばれる  
準備が完了したら通知をもらう(イベント駆動モデル)  

### 非同期・ノンブロッキングモデル

メインプロセスのスレッドとは完全に別のスレッドでタスクを行い、完了したら  
通知だけを受け取るという仕組み

POSIXの非同期I/O(aio_*)が有名 (まだ実装が成熟していない)

LinuxカーネルにもAIOというのがあるが、あこれもあまり使われていない

### Goで非同期

Goは並列処理が得意、主にgoroutine, チャネル, selectで実現する


* goroutineをたくさん実行して、それぞれに同期・ブロッキングI/Oをまかせると、全体では、非同期・ノンブロッキングに見える
* goroutineで並列化した、I/Oの入出力でチャネルを使うと、他のgoroutineとやり取りする箇所のみ同期できる
* ↑のチャネルにバッファがあれば、書き込みがわもノンブロッキングにできる
* さらにこのチャネルにselectを使うと非同期・ブロッキングにできる
* selectにdefaultがあると、読み込みをノンブロッキングでできるようになり、非同期I/Oにできる 