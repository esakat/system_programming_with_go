# 10章のメモ(ファイルシステムの最深部を扱う)

`os`パッケージだけで扱えない奴を試してみる

## ファイルの変更監視(syscall.lnotify)

ファイルの変更を監視して、ビルドなどをするようにする  
方法は以下2つがある

* 監視したいファイルをOS側に通知しておいて、変更があったら教えてもらう(パッシブ方式)
* タイマーなどで定期的にフォルダを走査して、変更を探す(アクティブ方式)

実装としては後者が簡単だが、監視対象が増えるとCPU負荷や、IO負荷が上がる。  
前者の方式は環境ごとのコード差が大きくなる

## ファイルのロック(syscall.Flock)

ファイルのロックは複数のプロセス間で同じリソースを同時に変更しないように今使用していると他のプロセスに伝えること  
シンプルな方法はリソースが使用中であることをファイル(ロックファイル)によって示す  
ロックファイルは確実性の面で劣る。より確実なのはシステムコールを使用すること(Goだと`syscall.Flock`)  
ただこちらは強制力のないロック(勧告ロック)になってしまう

またこれはWindowsでは使えない。Windowsで使える`LockFileEx()`では強制ロックになる

ファイルのような共有リソースのロックには、共有ロックと排他ロックという区別があります。
共有ロックは複数プロセスから1つのリソースに同時にかけれる。  
排他ロックでは他のプロセスからの共有ロックがブロックされる  

Flockではすでロックされているファイルに対してロックをかけようとすると、最初のロックが外れるまで待たされる
ので、定期的になんどもアクセスしてロックが取得できるかトライすることが出来ない。
これを可能にするのが`ノンブロッキングモード`

## ファイルのメモリへのマッピング

`os.File`を使うと読み込む位置を指定して、そこに移動しないといけない  
`syscall.Mmap()`を使うと、ファイルをメモリ上に展開して、メモリ上で操作して、それをファイルに反映できる  
