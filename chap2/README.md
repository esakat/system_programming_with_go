# 2章のメモ

<!-- TOC -->

- [2章のメモ](#2章のメモ)
  - [ファイルディスクリプタ](#ファイルディスクリプタ)
  - [インターフェース](#インターフェース)
  - [io.Writerを再確認](#iowriterを再確認)
    - [もう少し踏み込んで](#もう少し踏み込んで)
  - [byteと文字列について](#byteと文字列について)
  - [io.Writerを使う構造体](#iowriterを使う構造体)
  - [io.Writerのデコレーター](#iowriterのデコレーター)
  - [インタフェースの実装状況](#インタフェースの実装状況)
  - [Go言語の簡易ファイル操作、ネットワーク操作に関して](#go言語の簡易ファイル操作ネットワーク操作に関して)
  - [まとめ](#まとめ)

<!-- /TOC -->

## ファイルディスクリプタ

前章で`syscall.Write()`が呼び出されているのを確認した
OSではこれが`ファイルディスクリプタ`と呼ばれている

ファイルディスクリプタは一種の識別子
この識別子を指定してシステムコールを呼ぶと、識別子と対応するモノ(ファイルに限らず色々)にアクセスできる

ファイルディスクリプタはOSがカーネルレイヤーで用意している抽象化の仕組み
ファイルじゃないものも擬似ファイル的に扱ってファイルディスクリプタを与えている

この章ではファイルディスクリプタの仕組みを言語レベルで抽象化している `io.Writer`について見て行く

io.WriterはGo言語のインターフェースで実装されている

## インターフェース

インターフェースは構造体などが満たすべき仕様
持つべきメソッドを表現するための言語機能
一般的なオブジェクト指向言語(Javaとか)のインタフェースと同じと考えて良い

Goにはクラスという概念がないが、代わりに構造体がメソッドを持てる
以下のようにfuncキーワードとメソッドのシグネチャ定義の間にレシーバー(`(h Hoge)`)を置くと、構造体にメソッドを定義できる

```Go
// Greatという構造体にSayというメソッドを定義している
func (g Great) Say() {
  fmt.Println(g.name)
}
```

あるインターフェース(Aとする)で宣言されているメソッドがデータ型に対して定義されている場合
`そのデータ型はAを満たす`と言える。これが一般的な静的型付け言語と異なるところで
インターフェースを満たす構造体を定義する際に特に`implements`などのキーワードは不要
構造体のインスタンスのポインタをインターフェース型の変数に代入することで、Go言語のコンパイラが
互換性をチェックする

```Go
// Talker型のインタフェース変数に構造体のポインタを代入している
var talker Talker
talker = &Greeter{"wozozo"}
```

メソッドが副作用を持つ場合(その時々によって引数に関わらず返り値が異なるような)、レシーバーもポインタ型で定義する
C言語と異なり、Goにはガベージコレクタがあるため、宣言時以外は特にポインタ意識しなくて良い
```Go
func (h *Hoge) Say() {
  ...
}
```

## io.Writerを再確認

File型に定義されているメソッドということが分かる

```Go
func (f *File) Write(b []byte) (n int, err error) {
  if f == nil {
    return 0, ErrIntavalid
  }
  n, e := f.write(b)
  :
}
```

### もう少し踏み込んで

File型の構造体へのポインタに対するメソッド(osパッケージが定義するFile型では、ファイルを表現するのに必要なデータが含まれている)

`Write(b []byte) (n int, err error)` というのは`[]byte`型を引数で受け取り、int型とerr型の2つの値を返す

このメソッドは`f`が示すファイルに`b`のバイト列を書き込んで、書き込んだバイト数`n`と結果`err`(errorが起きなかったら`nil`が入る)を返す

---

書き込んだバイト数`n`と結果`err` というのはファイル書き込みだけでなく、もっと汎用的に扱えそう
これをインタフェースとして定義してるのが`io.Writer`

```Go
type Writer interface {
  Write(p []byte) (n int, err error)
}
```

上記の`Write()`はこのインタフェースを`*File`構造体に定義した形である

## byteと文字列について

Go言語においてはbyteと文字列のstringが相互変換可能

```Go
// byteArray = []byte{0x41, 0x53, 0x43, 0x49, 0x49}
byteArray := []byte("ASCII")

// str = "ASCII"
srt := string([]byte{0x41, 0x53, 0x43, 0x49, 0x49})
```

## io.Writerを使う構造体

io.WriterインターフェースはGoのいろんな構造体で実装されている(満たされている)

インタフェースはあくまで`何ができるか`を宣言しているだけ

(例) 書き込む処理でも、ファイルであったり、バッファからであったり、インターネット経由であったりあるが、全て`n`バイトを書き込んで、同じ結果を返すと定義できるよね(もちろん中身の処理は違うけどね)

このフォルダ内においたいろんなサンプルは皆io.Writerインタフェースを満たしている
(処理は違うけど、書いてるプラグラムは似てるよね)

## io.Writerのデコレーター

デコレーターは`オブジェクトをラップして、築城の機能を実現する--GoFのデザインパターン用語`

C言語の場合はprintf()関数で出力する場合バッファリングで呼ばれるが
Go言語の場合、どの出力も基本的にバッファリングを行わない
基本的にはそれでもさほどオーバーヘッドは発生しないが、大量サイズの入出力、高頻度の入出力が行われる場合はバッファリングを入れるように設計した方が良い

## インタフェースの実装状況

前述の通り、JavaやC++と違い
Go言語では明示的にある構造体が「インタフェースを満たしている」とは書かない(`implements`書かない的な)

この判別はインタフェースの変数に構造体のポインタを代入か
メソッドの引数にポインタを渡すときに自動的に確認される

これを調べるには`godoc`を使うと良い(goインストールじに付属)
これはオフラインでgoのドキュメントをみれるようになる

```sh
# -analysis typeをつけるとインタフェース解析をしてくれる
# デフォでGOPATH以下を検索するので、色々いれてると思いよ
$ godoc --http ":6060" -analysis type
```

http://localhost:6060/pkg/io/#Writer

上で見れるよ

`-analysis type`をつけて実行すると、implementsという項目が追加される
これで実装状況を把握できる

## Go言語の簡易ファイル操作、ネットワーク操作に関して

Go言語では簡単にファイル操作などができる

例えば`ioutil.WriteFile()`だけでファイル書き込みが可能
けどこれは内部で、この章で学んだ`io.Reader`や`io.Writer`を使って実装されてる

低レベルAPIを組み合わせて、高レベルな関数を作る

`hoge | moge | test | momo |`

パイプみたいな`UNIX哲学`ですね

## まとめ

この章ではGo言語におけるインタフェースの仕組みを学んだ
特にio.Writerインタフェースを実装している構造体を中心に学んでいった