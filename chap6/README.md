# 6章のメモ(TCPソケットとHTTPの実装)

この章ではネットワーク...ソケット通信について  
HTTPの機能を再現しながら学んでいく。

## ネットワークの基本(プロトコルとレイヤー)

ネットワークを通じて、送信者と受信者間で通信を行うにはルールを共有する必要がある  
このルールのことを`プロトコル(通信規約)`という

ネットワークではいくつかのレイヤー(TCP/IP参照モデルとか)に分けられており  
そのレイヤ毎にプロトコルが定義されている。

アプリケーションを作る場合、意識する必要があるのはトランスポート層(TCP/UDP/..)から上だけでよい。  
Go言語ではTCP/UDP、それより上位のHTTPが組み込みの機能で提供されている。

## HTTPとその上のプロトコル

### HTTPのきほん

よく使われるアプリケーション層におけるプロトコルの1つである  
HTTPの基本をまとめていく(HTTP1.0ベース)

HTTPではクライアントのリクエストとサーバのレスポンスが規定されている

クライアントのリクエストは以下のような感じ
```HTTP
メソッド パス HTTP/1.0
ヘッダー1: ヘッダーの値
ヘッダー2: ヘッダーの値
(空行)
リクエストボディー
...
```

1行目でメソッド定義(GETとかPOSTとか)がきます。
その後ヘッダーがありボディがきます。
解析をシンプルに行うため、改行を区切り文字として定義しています。

サーバーのレスポンスは以下のようになっています
```HTTP
HTTP/1.0 200 OK
ヘッダー1: ヘッダーの値
ヘッダー2: ヘッダーの値
(空行)
サーバーレスポンス
```
1行目の`200`はレスポンスの種類で、レスポンスが成功したことを表している。  

HTTPはもともとシンプルな連絡手段だったが、インターネットの普及と共に要求される機能も増えてきた。

### RPC

`Remote Procedure Calling`

サーバに用意されている機能を、ローカルにあるかのように呼び出す仕組み

規格としては`JSON-RPC`,`XML-RPC`などがある。  
JSON-RPCはGoでも標準ライブラリとして提供されている

RPCではHTTPのボディ部分にプロトコルに従ったメッセージを入れてやり取りする
```HTTP
HTTP/1.0 200 OK
ヘッダー1: ヘッダーの値
ヘッダー2: ヘッダーの値
(空行)
<?xml version="1.0">...
<hoge>
  ...
</hoge>
```

### REST

`Representational State Transfer`

ウェブサービスをすベて階層化されたリソースとして表現し、やり取りを行うもの

RESTの思想に従ったシステムをRESTfulと呼ぶ  
最近ではRESTfulの究極形態として`HATEOAS`というのが注目を浴びている  
これはHTTPレスポンスに`リンク`情報を入れて、そこからクライアントプラグラムが自律的にデータ探索をして情報を見つける仕組み(リンクにnextとかprevの情報をもたせてる)(githubのissueがいい例)

### GraphQL

最近注目されているFacebookが提唱している、RPCベースのプロトコル  
SNSなどではリソースが綺麗な階層構造で表現できず、複数の属性から構成されることがある.

複数の属性で構成される要素をピンポイントで取得するための仕組みがGraphQL

## ソケット

アプリケーションを作る際は基本的にアプリケーション層のプロトコルのみを意識すればいい  
では、例えばHTTPはどのような下位レイヤーの仕組みを使っているか

ほとんどのOSではアプリケーション層からトランスポート層のプロトコルを利用するとき`ソケット`という仕組みを利用している。
(ちなみにTLS(SSL)はソケットとHTTPの間に入って暗号化を行う)

一般に他アプリケーションとの通信のことを`プロセス間通信`と呼ぶ  
ソケットもプロセス間通信の1種

ソケットが他とは違うのは、IPアドレスとポートさえ分かれば、ローカルだけでなく外部サーバともやり取りできること。

ソケットにはいくつか種類があるが、このほんで説明するのは

### TCP

もっともよく使われる安全性の高いソケット
スリーハンドシェイクを行ったのちに通信

### UDP

通信開始が早い。相手に一方的に送りつける

### Unixドメインソケット

ローカル通信限定だが、最速

アプリケーション間のインターネット通信もこれらのソケットを通じて行われる.

## ソケット通信の基本構造

ソケットは基本的に以下の構造になる

* サーバ: ソケットを開いて待ち受ける
* クライアント: 開いているソケットに接続して、通信を行う

Go言語では`Listen()`メソッドでサーバーを呼び、クライアントは`Dial()`メソッドを利用する

通信が確立すると、送信側、受信側どちらにも、相手と通信を行うための`net.Conn`インタフェースを満たすオブジェクトがわたされる。

`net.Conn`は通信のための共通機能が実装されたインタフェースで、io.Reader, io.Writer,io.Closerのメソッドに加えて、タイムアウト設定用のメソッドが追加されている

Go言語でクライアント側を表すと
```go
conn, err := net.Dial("tcp", "localhost:8080")
if err != nil {
  panic(err)
}
// connを使って処理
```

サーバサイドは以下の形だが、これは1度接続すると処理が終了してしまう
```go
ln, err := net.Listen("tcp", ":8080")
if err != nil {
  panic(err)
}
conn, err := ln.Accept()
if err != nil {
  // handle error
}
// connを使った処理
```


何度も処理を受け付けて、接続処理中も他の接続を受け付けたりできるようにするシンプルな実装は以下

```go
ln, err := net.Listen("tcp", ":8080")
if err != nil {
  panic(err)
}
// 1度で処理が終了しないようにAccept()を何度も呼び出す
for {
  conn, err := ln.Accept()
  if err != nil {
    // handle error
  }
  // 1リクエスト処理中に他のリクエストのAcceptが行えるように
  // Goroutineで非同期にレスポンスを処理する
  go func() {
    // connを使った処理
  }()
}
```

## Go言語でHTTPサーバ

go言語の組み込み機能(net.Conn)だけでHTTP通信を実現してみる

このコードで通信は行えたが、ソケットがボトルネックになりやすい  
また通信が切れたり、タイムアウトなどのエラーが発生する可能性もある

いくつかの通信高速化方法を見ていく.

## 速度改善 1. HTTP/1.1のKeep-Alive

HTTP/1.0では１セットの通信が終わるたびにコネクションが切れる  
Keep-Aliveを使うことで、しばらくの間TCP接続のコネクションを維持して使いまわすことができる

TCPでは１接続の確立に1.5RTT(ラウンドトリップタイム)かかる。(切断時も1.5RTT)  
物理的な距離や回線速度でRTTの時間は変わるがRTTが通信速度に影響を与えるのはいうまでもない  
Keep-Aliveを使えば、このオーバヘッドがなくせる

## 速度改善 2. 圧縮

圧縮をすると、通信速度自体は変わらないが、通信時間は短くなる  
gzip圧縮を実装してみる

### gzip対応クライアント

リクエスト生成時に自分が対応しているアルゴリズムを宣言する　 
リクエストヘッダーの`Accept-Encoding`で「このクライアントはgzip圧縮対応」というのを記述する

またレスポンスを受け取った際に圧縮されたデータを復元できる処理を入れる