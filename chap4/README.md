# 4章 チャネル

チャネルは低レベルアクセスの抽象化だけでなく、並列処理にも利用される

## goroutine

Go言語にはOSのネイティブなスレッドを扱いやすくした`goroutine`がある  

## チャネル

`チャネル`はFIFOのキューに並列処理アクセスを保証する機能を組み合わせたもの  

以下3つの性質がある

### チャネルは、データを順序よく受け渡すためのデータ構造

キューの上に実装されており、ランダムアクセスは不可  
投入と取り出しのみ可能  
TCPソケットの順序取り出しなどに利用できる

### チャネルは、並列処理されても正しくデータを受け渡す同期構造

チャネルは整合性が壊れることがない、安全なデータ構造になっている  
同時に複数のgoroutineでチャネルに読み書きを行っても  
1つのgorotineのみが取り出し、書き込みできる  
Go言語ではgoroutine間の情報共有方法として、goroutineを推奨している

### チャネルは、読み込み・書き込みで準備ができるまでブロックする機能

チャネルが他のデータ構造と違う点は  
データがない状態で読み込みをしようとすると、他のgoroutineがデータを投入して  
読み込み可能になるまで、ブロックして待つこと  

またバッファに空きがない状態で書き込みしようとすると、他のgoroutineが取り出して空きができるまで、ブロックする


Go言語でチャネルを使うときの例としては  
データ入力元、データ出力先、終了状態の伝達などに利用される

Go1.7からは`コンテキスト(context.Context)`という仕組みが導入された  
これはで終了とタイムアウト管理を行うが、終了判定にチャネルを介している

システムプログラミングでは、`読み込み・書き込みの準備ができるまでブロックする`という機能がキモとなる

##  チャネルの使用方法

`make()`で宣言  
3つ目の引数を指定すると、バッファあり---引数をつけないと、バッファなしのチャネルが作られる

```Go
// バッファなし
tasks := make(chan string)
// バッファ付き
tasks := make(chan string, 10)
```

チャネルへのデータ送信、受信には`<-`演算子を使う

```Go
// データを送信
tasks <- "cmake .."
tasks <- "cmake . --build Debug"

// データを受け取り
task := <-tasks
// データを受け取り&クローズ判定
task, ok := <-tasks
// データを読み捨てる場合は代入も不要
<-tasks
```

バッファなしでは受け取り側が受信しないと送信側もブロックされる  
前章の`io.Pipe`と似た動作

うけとりじは1or2の変数で受け取れる
1つ目の変数(上記例だと`task`)は受信したデータが格納される  
2つ目の変数(上記例だと`ok`)はbool型の変数で、チャネルがまだオープンであれば`true`が格納される

読み込みは基本的に送信側が送信されるまでブロックされる、これを避けるには`select`を使う

チャネルを閉じる場合は`Close(チャネル)`を呼び出す