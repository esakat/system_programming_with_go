# 4章 チャネル

チャネルは低レベルアクセスの抽象化だけでなく、並列処理にも利用される

## goroutine

Go言語にはOSのネイティブなスレッドを扱いやすくした`goroutine`がある  

## チャネル

`チャネル`はFIFOのキューに並列処理アクセスを保証する機能を組み合わせたもの  

以下3つの性質がある

### チャネルは、データを順序よく受け渡すためのデータ構造

キューの上に実装されており、ランダムアクセスは不可  
投入と取り出しのみ可能  
TCPソケットの順序取り出しなどに利用できる

### チャネルは、並列処理されても正しくデータを受け渡す同期構造

チャネルは整合性が壊れることがない、安全なデータ構造になっている  
同時に複数のgoroutineでチャネルに読み書きを行っても  
1つのgorotineのみが取り出し、書き込みできる  
Go言語ではgoroutine間の情報共有方法として、goroutineを推奨している

### チャネルは、読み込み・書き込みで準備ができるまでブロックする機能

チャネルが他のデータ構造と違う点は  
データがない状態で読み込みをしようとすると、他のgoroutineがデータを投入して  
読み込み可能になるまで、ブロックして待つこと  

またバッファに空きがない状態で書き込みしようとすると、他のgoroutineが取り出して空きができるまで、ブロックする


Go言語でチャネルを使うときの例としては  
データ入力元、データ出力先、終了状態の伝達などに利用される

Go1.7からは`コンテキスト(context.Context)`という仕組みが導入された  
これはで終了とタイムアウト管理を行うが、終了判定にチャネルを介している

システムプログラミングでは、`読み込み・書き込みの準備ができるまでブロックする`という機能がキモとなる

##  チャネルの使用方法

`make()`で宣言  
3つ目の引数を指定すると、バッファあり---引数をつけないと、バッファなしのチャネルが作られる

```Go
// バッファなし
tasks := make(chan string)
// バッファ付き
tasks := make(chan string, 10)
```

チャネルへのデータ送信、受信には`<-`演算子を使う

```Go
// データを送信
tasks <- "cmake .."
tasks <- "cmake . --build Debug"

// データを受け取り
task := <-tasks
// データを受け取り&クローズ判定
task, ok := <-tasks
// データを読み捨てる場合は代入も不要
<-tasks
```

バッファなしでは受け取り側が受信しないと送信側もブロックされる  
前章の`io.Pipe`と似た動作

うけとりじは1or2の変数で受け取れる
1つ目の変数(上記例だと`task`)は受信したデータが格納される  
2つ目の変数(上記例だと`ok`)はbool型の変数で、チャネルがまだオープンであれば`true`が格納される

読み込みは基本的に送信側が送信されるまでブロックされる、これを避けるには`select`を使う

チャネルを閉じる場合は`Close(チャネル)`を呼び出す

チャネルを閉じると、そのチャネルを使っているループが終了する

読み込みではデフォルト値(数値なら`0`, 文字列なら`空文字`)が返ってくるようになる  
送信しようとするpanicが発生する

### イベント通知としてのチャネル

```Go
func main() {
	fmt.Println("start sub()")
	// 終了を受け取るためのチャネル
	done := make(chan bool)
	go func() {
		fmt.Println("sub() is finished")
		// 終了を通知
		done <- true
	}()
	<-done
	fmt.Println("all tasks are finished")
}
```

`<-done`の受信部で終了通知送信を受け取らないとデッドロックが発生する

```
$ go run main.go
start sub()
sub() is finished
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
main.main()
        /Users/tom_red/work/sytem_programming_with_go/chap4/chanel_info/main.go:16 +0xf7
exit status 2
```

注意として、確実にチャネルがクローズされているかを確認できない  
クローズされるとデフォルト値が返ってくるので、正常な送信の`0`かデフォルト値としての`0`か見分けがつかない

チャネルはクローズしなくてもガベージコレクタで回収される。  
テータを扱うチャネルに関しては不正値が紛れる可能性もあるのであまり、クローズはしないほうがいい

### チャネルの状態

バッファなし、バッファあり、閉じたチャネルという状態によって  
送信、受信の振る舞いが異なるのを留意する.

### for文とチャネル

for文とチャネルとの連携はよく使われるので覚えておく

`for 変数 := range チャネル` の時、チャネルに値が入るたびに、ループが回るようになっている.  
(バッファの有無にかかわらず)  
(チャネルがクローズすると、forループも閉じる)

```go
	// pnはチャネルとする
	pn := primeNumber()
	for n := range pn {
		fmt.Println(n)
	}
```

この時、pnを値が来るたびにループが回る、個数未定の動的配列として扱える

### チャネルとselect文

終了フラグとデータ自身用のチャネルが2つある場合などに、データの到着順を意識しない、ブロックが発生したり、意図した動作をしないことがある  
複数のチャネルを同時に並列で受け付けて、データが到着したチャネルから順にとりだして処理するのにselect文を使う

基本的な使い方
```go
// selectは1度トリガーすると終了するため、forループ内で使用されることが多い
for {
	// dataとexitという2つのチャネルを並列で処理
	select {
		case data := <-reader:
			// 読み込んだデータを利用
			...
		case <- exit:
			// ループを抜ける
			break
	}
}
```

`default`を指定すると、その処理が実行されブロックされない  
これはポーリング(同期のために外部問い合わせ処理など)でループを回したい場合などに利用される

```Go
for {
	// ループ回すたびにポーリングして、データが入った時のみ処理したり
	reader, err := net.Dial("tcp", "localhost://api/sync")
	select {
		case data := <-reader:
			// 読み込んだデータを利用
			...
		default:
			// まだデータがきていない
			break
	}
}
```

### コンテキスト

Goの1.7から追加された機能  
深いネストや複雑なロジック内で、正しく終了/キャンセル/タイムアウトなどが行える機能

メソッドないで`cancel()`を実行すると終了できる  
`context.WithCancel(context.Background())`で受け取ることができる


